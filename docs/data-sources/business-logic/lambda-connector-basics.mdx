---
sidebar_position: 3
sidebar_label: Lambda Connector Basics
description:
  "Learn how to add a lambda connector to empower PromptQL with custom business logic that can be used to act on a
  user's behalf."
toc_max_heading_level: 2
keywords:
  - hasura
  - promptql
  - business logic
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import Thumbnail from "@site/src/components/Thumbnail";
import Prereqs from "@site/docs/_prereqs.mdx";

# Lambda Connector Basics

You can use lambda connectors to give PromptQL abilities to execute custom business logic on behalf of the user.

Using Hasura DDN, we can add a Lamdba connector runtime in Node.js with **TypeScript**, **Python**, or **Go**, and
expose functions to PromptQL as tools it can use.

## Initialize a lambda connector

In an existing supergraph project, you can add a new lambda connector by running the following command to start the
process in the DDN CLI in interactive mode:

```ddn title="Initialize a new connector in a project directory:"
ddn connector init <your_name_for_the_connector> -i
```

Choose the lambda connector to correspond with the language you'd like to use for your functions.

<Tabs groupId="source-preference" className="api-tabs">

<TabItem value="TypeScript" label="TypeScript">

When you add the `hasura/nodejs` connector, the CLI will generate a Node.js package with a `functions.ts` file. This
file is the entrypoint for your connector.

As this is a Node.js project, you can easily add any dependencies you desire by running `npm i <package-name>` from this
connector's directory.

</TabItem>
<TabItem value="Python" label="Python">

When you add the `hasura/python` connector, the CLI will generate a Python application with a `functions.py` file. This
file is the entrypoint for your connector.

As this is a Python project, you can easily add any dependencies you desire by adding them to the `requirements.txt` in
this connector's directory.

</TabItem>
<TabItem value="Go" label="Go">

When you add the `hasura/go` connector, the CLI will generate a Go application with a `/functions` directory. The
connector will use this directory — and any `*.go` file in it — as the entrypoint for your connector.

As this is a Go project, you can easily add any dependencies you desire by adding them to the `go.mod` file and running
`go mod tidy` from this connector's directory.

</TabItem>

</Tabs>

## Basic lambda functions

The following examples show how to create basic lambda functions in each language. You can replace the contents of the
`functions.ts`, `functions.py`, or `functions.go` file with the following examples.

<Tabs groupId="source-preference" className="api-tabs">

<TabItem value="TypeScript" label="TypeScript">

```ts title="<subgraph-name>/connector/<connector-name>/functions.ts"
/**
 * Takes an optional name parameter and returns a friendly greeting string
 * @param {string} [name] - Optional name to personalize the greeting
 * @returns {string} A greeting in the format "hello {name}" or "hello world" if no name provided
 * @readonly
 */
export function hello(name?: string) {
  return `hello ${name ?? "world"}`;
}
```

The JSDoc comments are optional, but the first general comment is highly recommended to help PromptQL understand the
function's purpose and parameters and will be added to the function's metadata.

The `@readonly` tag indicates that the function does not modify any data, and PromptQL will be able to call this without
asking for confirmation. Under the hood, DDN will create an NDC function for `@readonly` functions and an NDC procedure
for functions that are not marked as `@readonly`.

</TabItem>
<TabItem value="Python" label="Python">

```python title="<subgraph-name>/connector/<connector-name>/functions.py"
from hasura_ndc import start
from hasura_ndc.function_connector import FunctionConnector
from typing import Annotated

connector = FunctionConnector()

@connector.register_query
def hello(name: str | None = None) -> str:
    """
    Takes an optional name parameter and returns a friendly greeting string
    """
    return f"hello {name or 'world'}"

if __name__ == "__main__":
    start(connector)
```

The docstring comments are optional, but they're highly recommended to help PromptQL understand the function's purpose
and parameters and will be added to the function's metadata.

The `register_query` decorator indicates that the function does not modify any data, and PromptQL will be able to call
this without asking for confirmation. To create functions that modify data, use the `register_mutation` decorator
instead.

</TabItem>
<TabItem value="Go" label="Go">

```go title="<subgraph-name>/connector/<connector-name>/functions/hello.go"
package functions

import (
	"context"
	"fmt"

	"hasura-ndc.dev/ndc-go/types"
)

// HelloArguments defines the input parameters
type HelloArguments struct {
	Name *string `json:"name"` // Pointer makes it optional
}

// HelloResult defines the return type
type HelloResult struct {
	Greeting string `json:"greeting"`
}

// FunctionHello takes an optional name parameter and returns a friendly greeting string
func FunctionHello(ctx context.Context, state *types.State, args *HelloArguments) (*HelloResult, error) {
	name := "world"
	if args.Name != nil {
		name = *args.Name
	}

	return &HelloResult{
		Greeting: fmt.Sprintf("hello %s", name),
	}, nil
}
```

Function names are important as they determine how the function will be exposed in the API:

- Functions starting with `Function` (like `FunctionHello`) are treated as queries (read-only)
- Functions starting with `Procedure` (like `ProcedureCreateUser`) are treated as mutations (data modifications)

The function documentation is highly recommended to help PromptQL understand the function's purpose and parameters and
will be added to the function's metadata.

</TabItem>

</Tabs>

## Supported types

<Tabs groupId="source-preference" className="api-tabs">

<TabItem value="TypeScript" label="TypeScript">

When creating TypeScript lambda functions, you can use the following types for parameters and return values:

### Basic scalar types

- `string` - Maps to NDC scalar type: `String`
- `number` - Maps to NDC scalar type: `Float`
- `boolean` - Maps to NDC scalar type: `Boolean`
- `bigint` - Maps to NDC scalar type: `BigInt` (represented as a string in JSON)
- `Date` - Maps to NDC scalar type: `DateTime` (represented as an ISO formatted string in JSON)

```ts
/**
 * Example of basic scalar types
 * @readonly
 */
export function calculateAge(birthDate: Date, currentYear: number): number {
  return currentYear - birthDate.getFullYear();
}
```

### Object types and interfaces

You can define custom object types and interfaces:

```ts
type User = {
  id: string;
  name: string;
  age: number;
};

interface Response {
  success: boolean;
  data: string;
}

/**
 * Example using custom types
 * @readonly
 */
export function processUser(user: User): Response {
  return {
    success: true,
    data: `User ${user.name} is ${user.age} years old`,
  };
}
```

### Arrays

Arrays of a single type are supported:

```ts
/**
 * Example using array types
 * @readonly
 */
export function sumNumbers(numbers: number[]): number {
  return numbers.reduce((sum, num) => sum + num, 0);
}
```

### Null, undefined, and optional properties

You can use null, undefined, or make properties optional:

```ts
/**
 * Example with optional and nullable parameters
 * @readonly
 */
export function formatName(firstName: string, lastName?: string, title: string | null = null): string {
  const formattedTitle = title ? `${title} ` : "";
  const formattedLastName = lastName ? ` ${lastName}` : "";
  return `${formattedTitle}${firstName}${formattedLastName}`;
}
```

### Arbitrary JSON

You can import `JSONValue` from the SDK to accept and return arbitrary JSON:

```ts
import * as sdk from "@hasura/ndc-lambda-sdk";

/**
 * Example using JSONValue for arbitrary JSON
 * @readonly
 */
export function transformData(data: sdk.JSONValue): sdk.JSONValue {
  // Process the JSON data
  return new sdk.JSONValue({ processed: true, original: data.value });
}
```

### Error handling

You can throw custom errors for better error handling:

```ts
import * as sdk from "@hasura/ndc-lambda-sdk";

/**
 * Example with error handling
 * @readonly
 */
export function divide(a: number, b: number): number {
  if (b === 0) {
    throw new sdk.UnprocessableContent("Cannot divide by zero", { a, b });
  }
  return a / b;
}
```

</TabItem>
<TabItem value="Python" label="Python">

When creating Python lambda functions, you can use the following types for parameters and return values:

### Basic scalar types

- `str` - Maps to NDC scalar type: `String`
- `int` - Maps to NDC scalar type: `Int`
- `float` - Maps to NDC scalar type: `Float`
- `bool` - Maps to NDC scalar type: `Boolean`
- `datetime` - Maps to NDC scalar type: `DateTime` (represented as an ISO formatted string in JSON)

```python
from datetime import datetime

@connector.register_query
def calculate_rough_age(birth_year: int, current_year: int) -> int:
    """
    Example of basic scalar types
    """
    return current_year - birth_year
```

### Object types with Pydantic

You can define custom object types using Pydantic models with field descriptions:

```python
from pydantic import BaseModel, Field
from typing import Annotated

class User(BaseModel):
    id: str = Field(..., description="Unique identifier for the user")
    name: Annotated[str, "User's full name"]
    age: int

class Response(BaseModel):
    success: bool
    data: str

@connector.register_query
def process_user(user: User) -> Response:
    """Example using custom types"""
    return Response(
        success=True,
        data=f"User {user.name} is {user.age} years old"
    )
```

### Lists and nested types

Lists and nested types are supported:

```python
from pydantic import BaseModel

class Pet(BaseModel):
    name: str

class Person(BaseModel):
    name: str
    pets: list[Pet] | None = None

@connector.register_query
def greet_person(person: Person) -> str:
    greeting = f"Hello {person.name}!"
    if person.pets is not None:
        for pet in person.pets:
            greeting += f" And hello to {pet.name}."
    else:
        greeting += f" I see you don't have any pets."
    return greeting
```

### Union types and optional properties

You can use union types to indicate multiple possible types:

```python
@connector.register_query
def format_name(first_name: str, last_name: str | None = None, title: str | None = None) -> str:
    """Example with optional and nullable parameters"""
    formatted_title = f"{title} " if title else ""
    formatted_last_name = f" {last_name}" if last_name else ""
    return f"{formatted_title}{first_name}{formatted_last_name}"
```

### Arbitrary JSON

You can use untyped parameters for arbitrary JSON:

```python
@connector.register_mutation
def transform_data(data) -> dict:
    """Example using untyped parameter for arbitrary JSON"""
    # Process the JSON data
    return {"processed": True, "original": data}
```

### Parallel execution

You can configure functions to run in parallel:

```python
import asyncio

@connector.register_query(parallel_degree=5)
async def parallel_query(name: str) -> str:
    """
    This function will be executed in parallel in batches of 5
    when joined in a query
    """
    await asyncio.sleep(1)
    return f"Hello {name}"
```

### Error handling

You can raise custom errors for better error handling:

```python
from hasura_ndc.errors import UnprocessableContent

@connector.register_query
def divide(a: float, b: float) -> float:
    """Example with error handling"""
    if b == 0:
        raise UnprocessableContent(message="Cannot divide by zero", details={"a": a, "b": b})
    return a / b
```

### Tracing support

Add additional OpenTelemetry tracing spans to your functions:

```python
from hasura_ndc.instrumentation import with_active_span
from opentelemetry.trace import get_tracer

tracer = get_tracer("ndc-sdk-python.server")

@connector.register_query
async def with_tracing(name: str) -> str:
    async def do_some_work(_span):
        # This could be an async network call or other operation
        return f"Hello {name}, tracing is active!"

    return await with_active_span(
        tracer,
        "Root Span",
        do_some_work,
        {"tracing-attr": "This attribute is added to the trace"}
    )
```

</TabItem>
<TabItem value="Go" label="Go">

When creating Go lambda functions, you can use the following types for parameters and return values:

### Basic scalar types

- `string` - Maps to NDC scalar type: `String`
- `int`, `int32`, `int64` - Maps to NDC scalar type: `Int`
- `float32`, `float64` - Maps to NDC scalar type: `Float`
- `bool` - Maps to NDC scalar type: `Boolean`
- `time.Time` - Maps to NDC scalar type: `DateTime` (represented as an ISO formatted string in JSON)

```go
package functions

import (
	"context"

	"hasura-ndc.dev/ndc-go/types"
)

type CalculateAgeArguments struct {
	BirthYear   int `json:"birthYear"`
	CurrentYear int `json:"currentYear"`
}

type CalculateAgeResult struct {
	Age int `json:"age"`
}

// FunctionCalculateAge calculates a person's age
func FunctionCalculateAge(ctx context.Context, state *types.State, args *CalculateAgeArguments) (*CalculateAgeResult, error) {
	return &CalculateAgeResult{
		Age: args.CurrentYear - args.BirthYear,
	}, nil
}
```

### Object types and structs

You can define custom struct types:

```go
package functions

import (
	"context"
	"fmt"

	"hasura-ndc.dev/ndc-go/types"
)

type User struct {
	ID   string `json:"id"`
	Name string `json:"name"`
	Age  int    `json:"age"`
}

type ProcessUserArguments struct {
	User User `json:"user"`
}

type ProcessUserResponse struct {
	Success bool   `json:"success"`
	Data    string `json:"data"`
}

// FunctionProcessUser demonstrates using custom struct types
func FunctionProcessUser(ctx context.Context, state *types.State, args *ProcessUserArguments) (*ProcessUserResponse, error) {
	return &ProcessUserResponse{
		Success: true,
		Data:    fmt.Sprintf("User %s is %d years old", args.User.Name, args.User.Age),
	}, nil
}
```

### Nullable and optional properties

You can use pointers to make properties optional:

```go
package functions

import (
	"context"
	"fmt"

	"hasura-ndc.dev/ndc-go/types"
)

type FormatNameArguments struct {
	FirstName string  `json:"firstName"`
	LastName  *string `json:"lastName"`   // Optional
	Title     *string `json:"title"`      // Optional
}

type FormatNameResult struct {
	FormattedName string `json:"formattedName"`
}

// FunctionFormatName demonstrates using optional parameters
func FunctionFormatName(ctx context.Context, state *types.State, args *FormatNameArguments) (*FormatNameResult, error) {
	formattedTitle := ""
	if args.Title != nil {
		formattedTitle = *args.Title + " "
	}

	formattedLastName := ""
	if args.LastName != nil {
		formattedLastName = " " + *args.LastName
	}

	return &FormatNameResult{
		FormattedName: fmt.Sprintf("%s%s%s", formattedTitle, args.FirstName, formattedLastName),
	}, nil
}
```

### Generic JSON

You can use `map[string]interface{}` or the `any` type for arbitrary JSON:

```go
package functions

import (
	"context"

	"hasura-ndc.dev/ndc-go/types"
)

type TransformDataArguments struct {
	Data map[string]interface{} `json:"data"`
}

type TransformDataResult struct {
	Processed bool                   `json:"processed"`
	Original  map[string]interface{} `json:"original"`
}

// FunctionTransformData demonstrates handling arbitrary JSON
func FunctionTransformData(ctx context.Context, state *types.State, args *TransformDataArguments) (*TransformDataResult, error) {
	return &TransformDataResult{
		Processed: true,
		Original:  args.Data,
	}, nil
}
```

### Error handling

You can return custom errors for better error handling:

```go
package functions

import (
	"context"
	"fmt"

	"hasura-ndc.dev/ndc-go/types"
)

type DivideArguments struct {
	A float64 `json:"a"`
	B float64 `json:"b"`
}

type DivideResult struct {
	Result float64 `json:"result"`
}

// FunctionDivide demonstrates error handling
func FunctionDivide(ctx context.Context, state *types.State, args *DivideArguments) (*DivideResult, error) {
	if args.B == 0 {
		return nil, fmt.Errorf("cannot divide by zero")
	}
	return &DivideResult{Result: args.A / args.B}, nil
}
```

</TabItem>

</Tabs>

## Retrieve information

We can use lambda connectors to allow PromptQL to query any API endpoint directly.

### Step 1. Call an external API

<Tabs groupId="source-preference" className="api-tabs">

<TabItem value="TypeScript" label="TypeScript">

Open the `app/connector/typescript/functions.ts` file.

```ts title="Replace the contents with the following:"
/**
 * Calls httpbin.org API to create a personalized greeting for the given name. Takes an optional name parameter and returns a friendly greeting string.
 * @param {string} [name] - Optional name to personalize the greeting
 * @returns {Promise<{ greeting?: string }>} A Promise resolving to an object containing the optional greeting message
 * @readonly
 */
export async function helloFromHttpBin(name?: string): Promise<{ greeting?: string }> {
  const greeting = { greeting: name };

  const response = await fetch("https://httpbin.org/post", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({ greeting: `Hello ${name}!` }),
  });

  const data: any = await response.json();
  return { greeting: data?.json?.greeting };
}
```

</TabItem>
<TabItem value="Python" label="Python">

Open the `app/connector/python/functions.py` file.

```python title="Replace the contents with the following:"
from hasura_ndc import start
from hasura_ndc.function_connector import FunctionConnector
import requests

connector = FunctionConnector()

@connector.register_query
async def hello_from_http_bin(name: str | None = None) -> dict:
    """
    Calls httpbin.org API to create a personalized greeting for the given name.
    Takes an optional name parameter and returns a friendly greeting string.
    """
    response = requests.post(
        "https://httpbin.org/post",
        json={"greeting": f"Hello {name}!"}
    )

    data = response.json()
    return {"greeting": data.get("json", {}).get("greeting")}

if __name__ == "__main__":
    start(connector)
```

</TabItem>
<TabItem value="Go" label="Go">

Open a new file in the functions directory:

```go title="<subgraph-name>/connector/<connector-name>/functions/hello_from_http_bin.go"
package functions

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"

	"hasura-ndc.dev/ndc-go/types"
)

// HelloFromHttpBinArguments defines the input parameters
type HelloFromHttpBinArguments struct {
	Name *string `json:"name"` // Optional name parameter
}

// HelloFromHttpBinResponse defines the return type
type HelloFromHttpBinResponse struct {
	Greeting *string `json:"greeting"` // Optional greeting response
}

// HTTPBinResponse represents the response from httpbin.org
type HTTPBinResponse struct {
	JSON struct {
		Greeting string `json:"greeting"`
	} `json:"json"`
}

// FunctionHelloFromHttpBin calls httpbin.org API to create a personalized greeting
func FunctionHelloFromHttpBin(ctx context.Context, state *types.State, args *HelloFromHttpBinArguments) (*HelloFromHttpBinResponse, error) {
	// Prepare the name to use
	name := "world"
	if args.Name != nil {
		name = *args.Name
	}

	// Create the request payload
	payload, err := json.Marshal(map[string]string{
		"greeting": fmt.Sprintf("Hello %s!", name),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create request payload: %w", err)
	}

	// Send the POST request to httpbin
	resp, err := http.Post("https://httpbin.org/post", "application/json", bytes.NewBuffer(payload))
	if err != nil {
		return nil, fmt.Errorf("HTTP request failed: %w", err)
	}
	defer resp.Body.Close()

	// Read and parse the response
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	var httpBinResp HTTPBinResponse
	if err := json.Unmarshal(body, &httpBinResp); err != nil {
		return nil, fmt.Errorf("failed to parse response: %w", err)
	}

	// Extract the greeting from the response
	greeting := httpBinResp.JSON.Greeting
	return &HelloFromHttpBinResponse{
		Greeting: &greeting,
	}, nil
}
```

</TabItem>

</Tabs>

### Step 2. Add the metadata

```ddn
ddn connector introspect <connector-name>
ddn commands list <connector-name>
```

You should see the command being `AVAILABLE` which means that it's not yet added to the supergraph.

```ddn
ddn commands add <connector-name> <command-name>
```

### Step 3. Create and run a new build and test the function

```ddn title="Create a new local build:"
ddn supergraph build local
```

```ddn title="Run your services:"
ddn run docker-start
```

```ddn title="In a new terminal tab, open the devlopment console:"
ddn console --local
```

Head over to the PromptQL Playground and see if the AI assistant is able to call your API integration.

```plaintext
say hello to everyone from httpBin
```

## Take action

You can use lambda connectors to add custom business logic to your application that takes action on behalf of a user.

### Step 1. Add custom logic

<Tabs groupId="source-preference" className="api-tabs">

<TabItem value="TypeScript" label="TypeScript">

```typescript title="Replace the contents of functions.ts with the following:"
/*
 * Interface for the response when taking action on behalf of a user.
 * Contains success status and message.
 */
interface UserActionResponse {
  success: boolean;
  message: string;
}

/*
 * This function simulates taking an action on behalf of a user. It logs the request made by the user
 * and returns a response object indicating the success status and a message.
 *
 * @param {string} request - What the user wants to do
 * @returns {UserActionResponse} - The response object containing success status and message
 */
export function takeActionOnBehalfOfUser(request: string): UserActionResponse {
  // In a real application, you'd replace this with your custom business logic.
  // You could update data in a database or use an API to update another service.
  console.log(`Taking action on behalf of user: ${request}`);
  return {
    success: true,
    message: `Successfully took action on user's behalf: ${request}`,
  };
}
```

The absence of the `@readonly` tag indicates that this function will modify data. PromptQL will ask for confirmation
before calling it.

</TabItem>

<TabItem value="Python" label="Python">

```python title="Replace the contents of functions.py with the following:"
from hasura_ndc import start
from hasura_ndc.function_connector import FunctionConnector
from pydantic import BaseModel, Field
from hasura_ndc.errors import UnprocessableContent
from typing import Annotated

connector = FunctionConnector()

class UserActionArguments(BaseModel):
    request: Annotated[str, Field(description="What the user wants to do")]

class UserActionResponse(BaseModel):
    success: bool
    message: str

@connector.register_mutation
def take_action_on_behalf_of_user(args: UserActionArguments) -> UserActionResponse:
    # In a real application, you'd replace this with business logic
    # You could update data in a database or use an API to update another service.
    print("Taking action on behalf of user")
    return UserActionResponse(
        success=True,
        message=f"Successfully took action on user's behalf: {args.request}"
    )

if __name__ == "__main__":
    start(connector)
```

</TabItem>

<TabItem value="Go" label="Go">

```go title="Add the following to a new file called app/connector/my_go/functions/take_action_on_behalf_of_user.go:"
package functions

import (
	"context"
	"fmt"

	"hasura-ndc.dev/ndc-go/types"
)

// TakeActionArguments represents the input arguments for a user action.
type TakeActionArguments struct {
	Request string `json:"request"`
}

// TakeActionResponse represents the response after performing a user action.
type TakeActionResponse struct {
	Success bool   `json:"success"`
	Message string `json:"message"`
}

// ProcedureTakeActionOnBehalfOfUser simulates taking an action for the user.
func ProcedureTakeActionOnBehalfOfUser(
	ctx context.Context,
	state *types.State,
	args *TakeActionArguments,
) (*TakeActionResponse, error) {
	// In a real application, you'd replace this with your custom business logic
  // You could update data in a database or use an API to update another service.
	fmt.Println("Taking action on behalf of user")

	return &TakeActionResponse{
		Success: true,
		Message: fmt.Sprintf("Successfully took action on user's behalf: %s", args.Request),
	}, nil
}
```

</TabItem>

</Tabs>

### Step 2. Introspect the source file(s)

<Tabs groupId="source-preference" className="api-tabs">

<TabItem value="TypeScript" label="TypeScript">

```ddn title="Introspect the connector:"
ddn connector introspect my_ts
```

```bash title="Then, we can generate a metadata file for each function using the following command:"
# alternatively, use ddn command add my_ts "*" for bulk adds
ddn command add my_ts take_action_on_behalf_of_user
```

</TabItem>

<TabItem value="Python" label="Python">

```ddn title="Introspect the connector:"
ddn connector introspect my_python
```

```bash title="Then, we can generate a metadata file for each function using the following command:"
# alternatively, use ddn command add my_python "*" for bulk adds
ddn command add my_python take_action_on_behalf_of_user
```

</TabItem>

<TabItem value="Go" label="Go">

```ddn title="Introspect the connector:"
ddn connector introspect my_go
```

```bash title="Then, we can generate a metadata file for each function using the following command:"
# alternatively, use ddn command add my_go "*" for bulk adds
ddn command add my_go take_action_on_behalf_of_user
```

</TabItem>

</Tabs>

The command introspected your connector's entrypoint, identified functions with their argument and return types, and
generated Hasura metadata for each. Look for `take_action_on_behalf_of_user.hml` to see the CLI-generated metadata.

:::info Add semantic metadata

We highly recommend adding a `description` to the command object referenced above. Why?

PromptQL's performance is improved by providing more context; if you guide its understanding of what a particular
function does and how it should be used in the application, you'll get better results.

:::

### Step 3. Create a new build and test

```ddn title="Create a new build:"
ddn supergraph build local
```

```ddn title="Start your services:"
ddn run docker-start
```

```ddn title="Open your local console:"
ddn console --local
```

You can now navigate to the PromptQL Playground and use your custom business logic with natural language.

<Thumbnail src="/img/business-logic/take-action.png" alt="Take action on behalf of user" />

## Next steps

While not wholly necessary, you can create explicit relationships between your custom business logic and existing types
from other datasources. Typically, PromptQL can pick up on the context of how to use your business logic in conjunction
with your data, but you can always improve its understanding by creating a
[relationship object](/data-modeling/relationship.mdx).
