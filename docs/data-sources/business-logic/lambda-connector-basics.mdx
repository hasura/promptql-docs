---
sidebar_position: 3
sidebar_label: Lambda Connector Basics
description:
  "Learn how to add a lambda connector to empower PromptQL with custom business logic that can be used to act on a
  user's behalf."
keywords:
  - hasura
  - promptql
  - business logic
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import Thumbnail from "@site/src/components/Thumbnail";
import Prereqs from "@site/docs/_prereqs.mdx";

# Lambda Connector Basics

You can use lambda connectors to give PromptQL abilities to execute custom business logic on behalf of the user.

Using Hasura DDN, we can add a Lamdba connector runtime in Node.js with TypeScript, Python, or Go, which will be exposed
to PromptQL as a tool it can use.

## Initialize a Lambda Connector

In an existing supergraph project, you can add a new lambda connector by running the following command:

```ddn title="Initialize a new connector in a project directory:"
ddn connector init <your_name_for_the_connector> -i
```

<Tabs groupId="source-preference" className="api-tabs">

<TabItem value="TypeScript" label="TypeScript">

When you add the `hasura/nodejs` connector, the CLI will generate a Node.js package with a `functions.ts` file. This
file is the entrypoint for your connector.

As this is a Node.js project, you can easily add any dependencies you desire by running `npm i <package-name>` from this
connector's directory.

</TabItem>
<TabItem value="Python" label="Python">

When you add the `hasura/python` connector, the CLI will generate a Python application with a `functions.py` file. This
file is the entrypoint for your connector.

As this is a Python project, you can easily add any dependencies you desire by adding them to the `requirements.txt` in
this connector's directory.

</TabItem>
<TabItem value="Go" label="Go">

When you add the `hasura/go` connector, the CLI will generate a Go application with a `/functions` directory. The
connector will use this directory — and any `*.go` file in it — as the entrypoint for your connector.

As this is a Go project, you can easily add any dependencies you desire by adding them to the `go.mod` file and running
`go mod tidy` from this connector's directory.

</TabItem>

</Tabs>

:::info Customization

You can customize which subgraph this connector is added to by
[changing your project's context](/reference/cli/commands/ddn_context.mdx) or using flags. More information can be found
in the [CLI docs](/reference/cli/commands/ddn_connector_init.mdx) for the `ddn connector init` command.

:::

## Retrieve Information with a Lambda Connector

### From API Endpoints

We can connect PromptQL to API endpoints to query them directly.

### Step 1. Initialize the connector

**Install the connector and say hello!**

```ddn
ddn connector init typescript -i
```

### Step 2. Introspect the connector

```ddn
ddn connector introspect typescript
ddn commands list typescript
```

You should see a default `hello` command being `AVAILABLE` which means that it’s not yet added to the supergraph.

### Step 3. Call an external API

Open the `app/connector/typescript/functions.ts` file.

```ts title="Replace the contents with the following:"
/**
 * This is an API to say hello from httpbin for a given name
 * @readonly
 */
export async function helloFromHttpBin(name?: string): Promise<{ greeting?: string }> {
  const greeting = { greeting: name };

  const response = await fetch("https://httpbin.org/post", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({ greeting: `Hello ${name}!` }),
  });

  const data: any = await response.json();
  return { greeting: data?.json?.greeting };
}
```

### Step 4. Add the metadata

```ddn
ddn connector introspect typescript
ddn commands list typescript
ddn commands add typescript helloFromHttpBin
```

### Step 5. Create and run a new build

```ddn title="Create a new local build:"
ddn supergraph build local
```

```ddn title="Run your services:"
ddn run docker-start
```

```ddn title="In a new terminal tab, open the devlopment console:"
ddn console --local
```

Head over to the PromptQL Playground and see if the AI assistant is able to call your API integration.

```plaintext
say hello from httpBin for everyone
```





# Take Action on Behalf of a User

## Introduction

In this tutorial, you'll use a lambda connector to add custom business logic to your application that takes action on
behalf of a user.

This tutorial should take about five minutes.

## Step 1. Initialize a new local DDN project

```ddn title="Create a new project using the DDN CLI:"
ddn supergraph init lambda-tutorial --with-promptql
```

## Step 2. Initialize the lambda connector

<Tabs groupId="source-preference" className="api-tabs">

<TabItem value="TypeScript" label="TypeScript">

```ddn title="Run the following command:"
ddn connector init my_ts -i
```

- Select `hasura/nodejs` from the list of connectors.
- Choose a port (press enter to accept the default recommended by the CLI).

If you open the `app/connector/my_ts` directory, you'll see the `functions.ts` file generated by the CLI; this will be
the entrypoint for your connector.

</TabItem>

<TabItem value="Python" label="Python">

```ddn title="Run the following command:"
ddn connector init my_python -i
```

- Select `hasura/python` from the list of connectors.
- Choose a port (press enter to accept the default recommended by the CLI).

If you open the `app/connector/my_python` directory, you'll see the `functions.py` file generated by the CLI; this will
be the entrypoint for your connector.

</TabItem>

<TabItem value="Go" label="Go">

```ddn title="Run the following command:"
ddn connector init my_go -i
```

- Select `hasura/go` from the list of connectors.
- Choose a port (press enter to accept the default recommended by the CLI).

If you open the `app/connector/my_go` directory, you'll see Go files in the `functions` folder; these will serve as the
entrypoint for your connector.

</TabItem>

</Tabs>

## Step 3. Add custom logic

<Tabs groupId="source-preference" className="api-tabs">

<TabItem value="TypeScript" label="TypeScript">

```bash title="From the connector directory, install the necessary packages:"
cd app/connector/my_ts && npm install
```

```typescript title="Then, replace the contents of functions.ts with the following:"
/*
 * This interface defines the structure of the response object returned by the
 * function that acts on behalf of a user. It includes a success status and a message.
 * The success status is a boolean indicating whether the operation was
 * successful or not.
 */
interface UserActionResponse {
  success: boolean;
  message: string;
}

/*
 * This function simulates taking an action on behalf of a user. It logs the request made by the user
 * and returns a response object indicating the success status and a message.
 *
 * @param {string} request - What the user wants to do
 * @returns {UserActionResponse} - The response object containing success status and message
 */
export function takeActionOnBehalfOfUser(request: string): UserActionResponse {
  // In a real application, you'd replace this with your custom business logic
  console.log(`Taking action on behalf of user`);
  return {
    success: true,
    message: `Successfully took action on user's behalf: ${request}`,
  };
}
```

</TabItem>

<TabItem value="Python" label="Python">

```python title="Replace the contents of functions.py with the following:"
from hasura_ndc import start
from hasura_ndc.function_connector import FunctionConnector
from pydantic import BaseModel, Field
from hasura_ndc.errors import UnprocessableContent
from typing import Annotated

connector = FunctionConnector()

class UserActionArguments(BaseModel):
    request: Annotated[str, Field(description="What the user wants to do")]

class UserActionResponse(BaseModel):
    success: bool
    message: str

@connector.register_mutation
def take_action_on_behalf_of_user(args: UserActionArguments) -> UserActionResponse:
    # In a real application, you'd replace this with business logic
    print("Taking action on behalf of user")
    return UserActionResponse(
        success=True,
        message=f"Successfully took action on user's behalf: {args.request}"
    )

if __name__ == "__main__":
    start(connector)
```

</TabItem>

<TabItem value="Go" label="Go">

```go title="Add the following to a new file called app/connector/my_go/functions/take_action_on_behalf_of_user.go:"
package functions

import (
	"context"
	"fmt"

	"hasura-ndc.dev/ndc-go/types"
)

// TakeActionArguments represents the input arguments for a user action.
type TakeActionArguments struct {
	Request string `json:"request"`
}

// TakeActionResponse represents the response after performing a user action.
type TakeActionResponse struct {
	Success bool   `json:"success"`
	Message string `json:"message"`
}

// ProcedureTakeActionOnBehalfOfUser simulates taking an action for the user.
func ProcedureTakeActionOnBehalfOfUser(
	ctx context.Context,
	state *types.State,
	args *TakeActionArguments,
) (*TakeActionResponse, error) {
	// In a real application, you'd replace this with your custom business logic
	fmt.Println("Taking action on behalf of user")

	return &TakeActionResponse{
		Success: true,
		Message: fmt.Sprintf("Successfully took action on user's behalf: %s", args.Request),
	}, nil
}
```

</TabItem>

</Tabs>

## Step 4. Introspect the source file(s)

<Tabs groupId="source-preference" className="api-tabs">

<TabItem value="TypeScript" label="TypeScript">

```ddn title="Introspect the connector:"
ddn connector introspect my_ts
```

```bash title="Then, we can generate a metadata file for each function using the following command:"
# alternatively, use ddn command add my_ts "*" for bulk adds
ddn command add my_ts take_action_on_behalf_of_user
```

</TabItem>

<TabItem value="Python" label="Python">

```ddn title="Introspect the connector:"
ddn connector introspect my_python
```

```bash title="Then, we can generate a metadata file for each function using the following command:"
# alternatively, use ddn command add my_python "*" for bulk adds
ddn command add my_python take_action_on_behalf_of_user
```

</TabItem>

<TabItem value="Go" label="Go">

```ddn title="Introspect the connector:"
ddn connector introspect my_go
```

```bash title="Then, we can generate a metadata file for each function using the following command:"
# alternatively, use ddn command add my_go "*" for bulk adds
ddn command add my_go take_action_on_behalf_of_user
```

</TabItem>

</Tabs>

The command introspected your connector's entrypoint, identified functions with their argument and return types, and
generated Hasura metadata for each. Look for `take_action_on_behalf_of_user.hml` to see the CLI-generated metadata.

:::info Add semantic metadata

We highly recommend adding a `description` to the command object referenced above. Why?

PromptQL's performance is improved by providing more context; if you guide its understanding of what a particular
function does and how it should be used in the application, you'll get better results.

:::

## Step 5. Create a new build and test

```ddn title="Create a new build:"
ddn supergraph build local
```

```ddn title="Start your services:"
ddn run docker-start
```

```ddn title="Open your local console:"
ddn console --local
```

You can now navigate to the PromptQL Playground and use your custom business logic.

<Thumbnail src="/img/business-logic/take-action.png" alt="Take action on behalf of user" />

## Next steps

While not wholly necessary, you can create explicit relationships between your custom business logic and existing types
from other datasources. Typically, PromptQL can pick up on the context of how to use your business logic in conjunction
with your data, but you can always improve its understanding by creating a
[relationship object](/data-modeling/relationship.mdx).

---

Notes:

Retrieve:

:::info Should you use a native data connector instead?

We've developed a set of native data connectors that make it easy to retrieve data from specific sources. You can learn
more [here](/data-sources/overview.mdx).

This guide is intended to illustrate use cases wherein a native data connector doesn't exist for your source, or you
need to do custom transformations of the data before its returned to your application.

:::

## Guide

You can access this tutorial [here](/how-to-build-with-promptql/with-api-endpoints.mdx).

Sometimes bulk loading data from API services might be overkill. In such cases, connecting to API endpoints directly is
useful or a convenient way to test your API integration.

However, if you expect to run into API rate limits, or need more flexible access to data that would require filtering
data in ways that the API doesn't natively allow for, consider
[bulk loading the data instead](/how-to-build-with-promptql/with-apis-with-bulk-data.mdx).
