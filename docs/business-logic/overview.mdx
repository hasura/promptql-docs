---
sidebar_position: 1
sidebar_label: Basics
description:
  "Learn how to incorporate custom business logic and make it available to PromptQL to act on a user's behalf."
keywords:
  - hasura
  - promptql
  - cicd
  - business logic
  - custom
---

# Basics of Business Logic

## Introduction

PromptQL can enable your application to act on a user's behalf by using **custom business logic** as a data source. This
logic can be tailored to each user's context — making decisions, aggregating data, or performing side effects — just
like a human assistant would.

With a **lambda connector**, you can write this logic in your language of choice (TypeScript, Python, or Go) and make it
available directly to PromptQL. That means PromptQL isn't limited to querying data — it can **trigger logic**, **run
workflows**, or **transform inputs into actions**, all within a secure and consistent API environment.

By treating logic like a first-class data source, PromptQL ensures your application has a unified surface for
interacting with databases, services, and whatever actions you want your application to be able to take. You define how
the system should respond to user queries, apply business rules, or even call third-party APIs.

Custom logic functions can work independently or extend your [models](/reference/metadata-reference/models.mdx), adding
intelligence or automation wherever it's needed.

This approach simplifies your architecture and unlocks a powerful new interaction model: **applications that respond,
reason, and act**...not just fetch data.

:::info What languages are supported?

You can write PromptQL-powered logic in TypeScript, Python, or Go. These functions can be hosted by Hasura or deployed
on your own infrastructure using our lambda connectors.

:::

## Functions and procedures

Regardless of which language you prefer, your connector will generate a
[command](/reference/metadata-reference/commands.mdx) in your metadata for each function. These commands will be
identified in your metadata as either [functions](/reference/metadata-reference/commands.mdx#command-functionname) — for
querying data — or [procedures](/reference/metadata-reference/commands.mdx#command-procedurename) — for modifying data —
via your API.

Each connector has its own conventions for determining if the custom logic you write is identified as either a function
or a procedure.

## Learn more

- [Learn how to add a lambda connector](/business-logic/add-a-lambda-connector.mdx)
- [Learn how to add independent custom logic to your application](/business-logic/tutorials/1-add-custom-logic.mdx)
- [Learn how to add custom logic to an existing model in your application](/business-logic/tutorials/2-extend-a-model.mdx)

:::info What about custom native operations?

If you're curious about native queries and mutations, check out the
[connector-specific reference docs](/reference/connectors/index.mdx) for generating queries and mutations using the
native capabilities of your data source.

:::
